<?php
/**
 * ProductTypeJsonld
 *
 * PHP version 5
 *
 * @category Class
 * @package  Ubiflow
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.56
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Ubiflow\Model;

use \ArrayAccess;
use \Ubiflow\ObjectSerializer;

/**
 * ProductTypeJsonld Class Doc Comment
 *
 * @category Class
 * @package  Ubiflow
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ProductTypeJsonld implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'ProductType.jsonld';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'id' => 'string',
        'type' => 'string',
        'context' => 'OneOfProductTypeJsonldContext',
        'code' => 'int',
        'description' => 'string',
        'language' => '\Ubiflow\Model\LanguageJsonld',
        'universe' => 'string',
        'relatedProfessions' => 'string[]',
        'level' => 'int',
        'parent' => 'string',
        'children' => 'string[]',
        'externalServiceCode' => '',
        'id' => 'int'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'id' => null,
        'type' => null,
        'context' => null,
        'code' => null,
        'description' => null,
        'language' => null,
        'universe' => 'iri-reference',
        'relatedProfessions' => 'iri-reference',
        'level' => null,
        'parent' => 'iri-reference',
        'children' => 'iri-reference',
        'externalServiceCode' => null,
        'id' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'id' => '@id',
        'type' => '@type',
        'context' => '@context',
        'code' => 'code',
        'description' => 'description',
        'language' => 'language',
        'universe' => 'universe',
        'relatedProfessions' => 'relatedProfessions',
        'level' => 'level',
        'parent' => 'parent',
        'children' => 'children',
        'externalServiceCode' => 'externalServiceCode',
        'id' => 'id'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'id' => 'setId',
        'type' => 'setType',
        'context' => 'setContext',
        'code' => 'setCode',
        'description' => 'setDescription',
        'language' => 'setLanguage',
        'universe' => 'setUniverse',
        'relatedProfessions' => 'setRelatedProfessions',
        'level' => 'setLevel',
        'parent' => 'setParent',
        'children' => 'setChildren',
        'externalServiceCode' => 'setExternalServiceCode',
        'id' => 'setId'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'id' => 'getId',
        'type' => 'getType',
        'context' => 'getContext',
        'code' => 'getCode',
        'description' => 'getDescription',
        'language' => 'getLanguage',
        'universe' => 'getUniverse',
        'relatedProfessions' => 'getRelatedProfessions',
        'level' => 'getLevel',
        'parent' => 'getParent',
        'children' => 'getChildren',
        'externalServiceCode' => 'getExternalServiceCode',
        'id' => 'getId'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }



    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['id'] = isset($data['id']) ? $data['id'] : null;
        $this->container['type'] = isset($data['type']) ? $data['type'] : null;
        $this->container['context'] = isset($data['context']) ? $data['context'] : null;
        $this->container['code'] = isset($data['code']) ? $data['code'] : null;
        $this->container['description'] = isset($data['description']) ? $data['description'] : null;
        $this->container['language'] = isset($data['language']) ? $data['language'] : null;
        $this->container['universe'] = isset($data['universe']) ? $data['universe'] : null;
        $this->container['relatedProfessions'] = isset($data['relatedProfessions']) ? $data['relatedProfessions'] : null;
        $this->container['level'] = isset($data['level']) ? $data['level'] : null;
        $this->container['parent'] = isset($data['parent']) ? $data['parent'] : null;
        $this->container['children'] = isset($data['children']) ? $data['children'] : null;
        $this->container['externalServiceCode'] = isset($data['externalServiceCode']) ? $data['externalServiceCode'] : null;
        $this->container['id'] = isset($data['id']) ? $data['id'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets id
     *
     * @return string
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param string $id id
     *
     * @return $this
     */
    public function setId($id)
    {
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets type
     *
     * @return string
     */
    public function getType()
    {
        return $this->container['type'];
    }

    /**
     * Sets type
     *
     * @param string $type type
     *
     * @return $this
     */
    public function setType($type)
    {
        $this->container['type'] = $type;

        return $this;
    }

    /**
     * Gets context
     *
     * @return OneOfProductTypeJsonldContext
     */
    public function getContext()
    {
        return $this->container['context'];
    }

    /**
     * Sets context
     *
     * @param OneOfProductTypeJsonldContext $context context
     *
     * @return $this
     */
    public function setContext($context)
    {
        $this->container['context'] = $context;

        return $this;
    }

    /**
     * Gets code
     *
     * @return int
     */
    public function getCode()
    {
        return $this->container['code'];
    }

    /**
     * Sets code
     *
     * @param int $code The identifier of the type of product described by the ad, in the Ubiflow IS.  When creating or updating an ad :  - Neither the code nor the description are mandatory.   But at least one of the two properties must be set.  - It is very important to define the code or description very accurately,   so that the ad get published in the right category on each portal :   otherwise users of the portals will not see the ad when using precise criteria,   which will result in less visibility and thus less contacts for the advertiser owning the ad.  - The most accurate way to define the product type is to do a complete mapping   between your own product types and Ubiflow's product types.   But this can be very tedious, so you can choose to make only a partial mapping,   for example using only Ubiflow's main product types (level one (1) and two (2)).   In this case, you should please add some more information about the product type,   by defining in the ProductType.description property the full string value of your own product type,   ie the descriptive value (and not a code name) as it is defined in your own IS.  - Anyway, it is part of Ubiflow's job to do its best to define the product type   more accurately, using the code of the product type and its description (if you set it),   the title and text of the ad, and any data enabling to have a better result.   So after POSTing or UPDATing an ad, don't be surprised   if the product type of the same ad you GET is different from the one you set.
     *
     * @return $this
     */
    public function setCode($code)
    {
        $this->container['code'] = $code;

        return $this;
    }

    /**
     * Gets description
     *
     * @return string
     */
    public function getDescription()
    {
        return $this->container['description'];
    }

    /**
     * Sets description
     *
     * @param string $description A short description of the type of product.  Neither the code nor the description are mandatory when creating or updating an ad. But at least one of the two properties must be set.  Refer to the ProductType.code property for more details.
     *
     * @return $this
     */
    public function setDescription($description)
    {
        $this->container['description'] = $description;

        return $this;
    }

    /**
     * Gets language
     *
     * @return \Ubiflow\Model\LanguageJsonld
     */
    public function getLanguage()
    {
        return $this->container['language'];
    }

    /**
     * Sets language
     *
     * @param \Ubiflow\Model\LanguageJsonld $language language
     *
     * @return $this
     */
    public function setLanguage($language)
    {
        $this->container['language'] = $language;

        return $this;
    }

    /**
     * Gets universe
     *
     * @return string
     */
    public function getUniverse()
    {
        return $this->container['universe'];
    }

    /**
     * Sets universe
     *
     * @param string $universe The universe related to the product type.
     *
     * @return $this
     */
    public function setUniverse($universe)
    {
        $this->container['universe'] = $universe;

        return $this;
    }

    /**
     * Gets relatedProfessions
     *
     * @return string[]
     */
    public function getRelatedProfessions()
    {
        return $this->container['relatedProfessions'];
    }

    /**
     * Sets relatedProfessions
     *
     * @param string[] $relatedProfessions A list of all professions related to the product type.
     *
     * @return $this
     */
    public function setRelatedProfessions($relatedProfessions)
    {
        $this->container['relatedProfessions'] = $relatedProfessions;

        return $this;
    }

    /**
     * Gets level
     *
     * @return int
     */
    public function getLevel()
    {
        return $this->container['level'];
    }

    /**
     * Sets level
     *
     * @param int $level The level of the type of product in the whole tree of product types.  The root product type has a level of one (1).  A descendant has a level of one (1) more than its parent.
     *
     * @return $this
     */
    public function setLevel($level)
    {
        $this->container['level'] = $level;

        return $this;
    }

    /**
     * Gets parent
     *
     * @return string
     */
    public function getParent()
    {
        return $this->container['parent'];
    }

    /**
     * Sets parent
     *
     * @param string $parent The parent of the current product type, in the tree of all product types.  The only product type who has no parent is the root of the tree.
     *
     * @return $this
     */
    public function setParent($parent)
    {
        $this->container['parent'] = $parent;

        return $this;
    }

    /**
     * Gets children
     *
     * @return string[]
     */
    public function getChildren()
    {
        return $this->container['children'];
    }

    /**
     * Sets children
     *
     * @param string[] $children The children of the current product type, in the tree of all product types.  A product type who has no children is a leaf of the tree.
     *
     * @return $this
     */
    public function setChildren($children)
    {
        $this->container['children'] = $children;

        return $this;
    }

    /**
     * Gets externalServiceCode
     *
     * @return 
     */
    public function getExternalServiceCode()
    {
        return $this->container['externalServiceCode'];
    }

    /**
     * Sets externalServiceCode
     *
     * @param  $externalServiceCode externalServiceCode
     *
     * @return $this
     */
    public function setExternalServiceCode($externalServiceCode)
    {
        $this->container['externalServiceCode'] = $externalServiceCode;

        return $this;
    }

    /**
     * Gets id
     *
     * @return int
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param int $id id
     *
     * @return $this
     */
    public function setId($id)
    {
        $this->container['id'] = $id;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    #[\ReturnTypeWillChange]
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    #[\ReturnTypeWillChange]
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    #[\ReturnTypeWillChange]
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}
